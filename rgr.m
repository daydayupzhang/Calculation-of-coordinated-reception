clear all; %Очистка памяти программы
close all; %Закрытие графиков предыдущих расчётов
Fd = 2047; %Частота дискретизации [Гц]
time = -0.125:1/Fd:0.125; %Время наблюдения сигнала [с]
Tu = 10*10^(-3); %Длительность заданного сигнала [с]
Ui = 2; %Амплитуда заданного сигнала [В]
t0 = 5*10^(-6); %Смещение середины заданного сигнала относительно начала координат [с]
tf = 0; %Время прохождения сигнала через фильтр[с]
q = -10; %Отношение сигнал/шум на входе [дБ]
fprintf('\n>>Вычисления при отношении с/ш на входе фильтра: %d[дБ] и частоте дискретизации %d[Гц]<< \n', q,Fd); %Вывод информации в командное окно 

% Часть №1
U1_in = Signal(time,Tu,Ui,t0); %Cигнал без шума на входе фильтра [В]
%U1_in = Ui*rectpuls(time,Tu); %Пробный прямоугольный сигнал [В]
figure; %Создание нового окна для графиков
plot (time, U1_in./max(U1_in),'LineWidth',2.5); %Построение эпюры нормированного сигнала без шума на входе фильтра(Рис. 1.1)
title(sprintf('Заданный сигнал без шума, нормированный к %d[B]',max(U1_in))); %Присвоение названия графику
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

% Часть №2.1 
S1_in = fftshift(fft(U1_in)); %Получение двустороннего спектра заданного сигнала без шума [В*с]
f = (-length(S1_in)/2:(length(S1_in)/2)-1)*(Fd/length(S1_in)); %Частоты спектра [Гц]

% Часть №2.2
norm2 = max(abs(S1_in)./Fd); %Максимум АЧС [В*с]
S1_05 = 0.5*max(S1_in); %Амплитуда по уровню 0.5 максимальной [В*с]
S1_01 = 0.1*max(S1_in); %Амплитуда по уровню 0.1 максимальной [В*с]
I_S1_05 = find(abs(S1_in)>=S1_05,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.5
I_S1_01 = find(abs(S1_in)>=S1_01,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.1
Passband1_05 = f(I_S1_05); %Полоса пропускания АЧС по уровню 0.5 [Гц]
Passband1_01 = f(I_S1_01); %Полоса пропускания АЧС по уровню 0.1 [Гц]
figure; %Создание нового окна для графиков
subplot(2,1,1); %Выбор верхней половины окна для отображения графика
plot(f,abs(S1_in./Fd)./norm2,'LineWidth',2.5); %Построение АЧС сигнала без шума на входе фильтра(Рис. 2.1)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('АЧС сигнала без шума, нормированный к %f[В*с]',norm2)); %Присвоение названия графику
xlabel('f'); %Название оси абсцисс графика
ylabel('S(f)/Smax'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

subplot (2,1,2); %Выбор нижней половины окна для отображения графика
plot (f,unwrap(angle(S1_in./Fd)),'LineWidth',2.5); %Построение ФЧС сигнала без шума на входе фильтра(Рис. 2.1)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title('ФЧС сигнала без шума на входе фильтра'); %Присвоение названия графику
xlabel('f'); %Название оси абсцисс графика
ylabel('\Psi(f) [рад]'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

% Часть №2.3
fprintf('Полоса пропускания АЧС для заданного сигнала по уровню 0.5: %f [Гц]\n', Passband1_05); %Вывод информации в командное окно
fprintf('Полоса пропускания АЧС для заданного сигнала по уровню 0.1: %f [Гц]\n', Passband1_01); %Вывод информации в командное окно

% Часть №3
Kmf1 = conj(S1_in); %КЧХ согласованного фильтра для заданного сигнала

% Часть №3.1
figure; %Создание нового окна для графиков
subplot (2,1,1); %Выбор верхней половины окна для отображения графика
norm4 = max(abs(Kmf1./Fd)); %Максимум АЧХ  [В*с]
plot (f,abs(Kmf1./Fd)./norm4,'LineWidth',2.5); %Построение АЧХ СФ
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('АЧХ СФ, нормированная к %f[В*с]',norm4));%Присвоение названия графику(Рис. 3.1)
xlabel('f');%Название оси графика
ylabel('S(f)/Smax'); %Название оси ординат графика
grid on; %Добавление сетки 

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

subplot (2,1,2); %Выбор нижней половины окна для отображения графика
plot (f,unwrap(angle(Kmf1./Fd)),'LineWidth',2.5); %Построение ФЧХ СФ
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title('ФЧХ СФ');%Присвоение названия графику(Рис. 3.1)
xlabel('f');%Название оси абсцисс графика
ylabel('\Psi(f) [рад]'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

% Часть №3.2
U2_in = Signal(time,Tu,0.8*Ui,t0); %Сигнал (-20% к амплитуде) без шума на входе фильтра [В]
U3_in = Signal(time,Tu,1.2*Ui,t0); %Сигнал (+20% от амплитуде) без шума на входе фильтра [В]
U4_in = Signal(time,1.2*Tu,Ui,t0); %Сигнала (+20% к длительности) без шума на входе фильтра [В]
U5_in = Signal(time,0.8*Tu,Ui,t0); %Сигнала (-20% от длительности) без шума на входе фильтра [В]
S2_in = fftshift(fft(U2_in)); %Получение двустороннего спектра сигнала (+20% к амплитуде) без шума [В*с]
S3_in = fftshift(fft(U3_in)); %Получение двустороннего спектра сигнала (-20% от амплитуде) без шума [В*с]
S4_in = fftshift(fft(U4_in)); %Получение двустороннего спектра сигнала (+20% к длительности)без шума [В*с]
S5_in = fftshift(fft(U5_in)); %Получение двустороннего спектра сигнала (-20% от длительности)без шума [В*с]

figure; %Создание нового окна для графиков
plot (time, U1_in./max(U1_in),'b', time, U2_in./max(U1_in),'--r','LineWidth',2.5); %Построение эпюры нормированного сигнала без шума на входе фильтра(Рис. 3.2)
title(sprintf('Сравнение сигналов с разным напряжением без шума, нормированных к %d[B]',max(U1_in))); %Присвоение названия графику
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
legend('Заданный сигнал','Сигнал с уменьшенной амплитудой'); %Описание линий на графике
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
plot (time, U1_in./max(U3_in),'b', time, U3_in./max(U3_in),'--r','LineWidth',2.5); %Построение эпюры нормированного сигнала без шума на входе фильтра(Рис. 3.4)
title(sprintf('Сравнение сигналов с разным напряжением без шума, нормированных к %g[B]',max(U3_in))); %Присвоение названия графику
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
legend('Заданный сигнал','Сигнал с увеличенной амплитудой'); %Описание линий на графике
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
plot (time, U1_in./max(U1_in),'b', time, U4_in./max(U1_in),'--r','LineWidth',2.5); %Построение эпюры нормированного сигнала без шума на входе фильтра(Рис. 3.6)
title(sprintf('Сравнение сигналов с разными длительностями без шума, нормированных к %d[B]',max(U1_in))); %Присвоение названия графику
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
legend('Заданный сигнал','Сигнал с увеличенной длительностью'); %Описание линий на графике
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
plot (time, U1_in./max(U1_in),'b', time, U5_in./max(U1_in),'--r','LineWidth',2.5); %Построение эпюры нормированного сигнала без шума на входе фильтра(Рис. 3.8)
title(sprintf('Сравнение сигналов с разными длительностями без шума, нормированных к %d[B]',max(U1_in))); %Присвоение названия графику
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
legend('Заданный сигнал','Сигнал с уменьшенной длительностью'); %Описание линий на графике
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
subplot (2,1,1); %Выбор верхней половины окна для отображения графика
norm2 = max(abs(S1_in)./Fd); %Максимум АЧС [В*с]
plot (f, abs(S1_in./Fd)./norm2, 'b', f, abs(S2_in./Fd)./norm2, '--r','LineWidth',2.5); %Построение АЧС сигнала без шума на входе фильтра(Рис. 3.3)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('Сравнение АЧС сигналов без шума, нормированных к %f[В*с]',norm2)); %Присвоение названия графику
legend('Заданный сигнал','Сигнал с уменьшенной амплитудой'); %Описание линий на графике
xlabel('f'); %Название оси абсцисс графика
ylabel('S(f)/Smax'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

subplot (2,1,2); %Выбор нижней половины окна для отображения графика
plot (f,unwrap(angle(S1_in./Fd)), 'b',f, unwrap(angle(S2_in./length(S2_in))), '--r','LineWidth',2.5); %Построение ФЧС сигнала без шума на входе фильтра(Рис. 3.3)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('Сравнение ФЧС сигналов без шума')); %Присвоение названия графику
legend('Заданный сигнал','Сигнал с уменьшенной амплитудой'); %Описание линий на графике
xlabel('f'); %Название оси абсцисс графика
ylabel('\Psi(f) [рад]'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
subplot (2,1,1); %Выбор верхней половины окна для отображения графика
norm23 = max(abs(S3_in)./Fd); %Максимум АЧС [В*с]
plot (f, abs(S1_in./Fd)./norm23, 'b',f, abs(S3_in./Fd)./norm23, '--r','LineWidth',2.5); %Построение АЧС сигнала без шума на входе фильтра(Рис. 3.5)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('Сравнение АЧС сигналов без шума, нормированных к %f[В*с]',norm23)); %Присвоение названия графику
legend('Заданный сигнал','Сигнал с увеличенной амплитудой'); %Описание линий на графике
xlabel('f'); %Название оси абсцисс графика
ylabel('S(f)/Smax'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

subplot (2,1,2); %Выбор нижней половины окна для отображения графика
plot (f,unwrap(angle(S1_in./Fd)), 'b',f, unwrap(angle(S3_in./Fd)), '--r','LineWidth',2.5); %Построение ФЧС сигнала без шума на входе фильтра(Рис. 3.5)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('Сравнение ФЧС сигналов без шума')); %Присвоение названия графику
legend('Заданный сигнал','Сигнал с увеличенной амплитудой'); %Описание линий на графике
xlabel('f'); %Название оси абсцисс графика
ylabel('\Psi(f) [рад]'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
subplot (2,1,1); %Выбор верхней половины окна для отображения графика
norm24 = max(abs(S4_in)./Fd); %Максимум АЧС [В*с]
plot (f, abs(S1_in./Fd)./norm24, 'b',f, abs(S4_in./Fd)./norm24, '--r','LineWidth',2.5); %Построение АЧС сигнала без шума на входе фильтра(Рис. 3.7)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('Сравнение АЧС сигналов без шума, нормированных к %f[В*с]',norm2)); %Присвоение названия графику
legend('Заданный сигнал','Сигнал с увеличенной длительностью'); %Описание линий на графике
xlabel('f'); %Название оси абсцисс графика
ylabel('S(f)/Smax'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

subplot (2,1,2); %Выбор нижней половины окна для отображения графика
plot (f,unwrap(angle(S1_in./Fd)), 'b',f, unwrap(angle(S4_in./Fd)), '--r','LineWidth',2.5); %Построение ФЧС сигнала без шума на входе фильтра(Рис. 3.7)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('Сравнение ФЧС сигналов без шума')); %Присвоение названия графику
legend('Заданный сигнал','Сигнал с увеличенной длительностью'); %Описание линий на графике
xlabel('f'); %Название оси абсцисс графика
ylabel('\Psi(f) [рад]'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
subplot (2,1,1); %Выбор верхней половины окна для отображения графика
plot (f, abs(S1_in./Fd)./norm2, 'b',f, abs(S5_in./Fd)./norm2, '--r','LineWidth',2.5); %Построение АЧС сигнала без шума на входе фильтра(Рис. 3.9)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('Сравнение АЧС сигналов без шума, нормированных к %f[В*с]',norm2)); %Присвоение названия графику
legend('Заданный сигнал','Сигнал с уменьшенной длительностью'); %Описание линий на графике
xlabel('f'); %Название оси абсцисс графика
ylabel('S(f)/Smax'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

subplot (2,1,2); %Выбор нижней половины окна для отображения графика
plot (f,unwrap(angle(S1_in./Fd)), 'b',f, unwrap(angle(S5_in./Fd)), '--r','LineWidth',2.5); %Построение ФЧС сигнала без шума на входе фильтра(Рис. 3.9)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('Сравнение ФЧС сигналов без шума')); %Присвоение названия графику
legend('Заданный сигнал','Сигнал с уменьшенной длительностью'); %Описание линий на графике
xlabel('f'); %Название оси абсцисс графика
ylabel('\Psi(f) [рад]'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

fprintf('\n'); %Пропуск строки
S2_05 = 0.5*max(S2_in); %Амплитуда по уровню 0.5 максимальной [В*с]
S2_01 = 0.1*max(S2_in); %Амплитуда по уровню 0.1 максимальной [В*с]
I_S2_05 = find(abs(S2_in)>=S2_05,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.5
I_S2_01 = find(abs(S2_in)>=S2_01,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.1
Passband2_05 = f(I_S2_05); %Полоса пропускания АЧС по уровню 0.5 [Гц]
Passband2_01 = f(I_S2_01); %Полоса пропускания АЧС по уровню 0.1 [Гц]
fprintf('Полоса пропускания АЧС для сигнала (с уменьшенной амплитудой) по уровню 0.5: %f [Гц]\n', Passband2_05); %Вывод информации в командное окно
fprintf('Полоса пропускания АЧС для сигнала (с уменьшенной амплитудой) по уровню 0.1: %f [Гц]\n', Passband2_01); %Вывод информации в командное окно
fprintf('\n'); %Пропуск строки
S3_05 = 0.5*max(S3_in); %Амплитуда по уровню 0.5 максимальной [В*с]
S3_01 = 0.1*max(S3_in); %Амплитуда по уровню 0.1 максимальной [В*с]
I_S3_05 = find(abs(S3_in)>=S3_05,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.5
I_S3_01 = find(abs(S3_in)>=S3_01,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.1
Passband3_05 = f(I_S3_05); %Полоса пропускания АЧС по уровню 0.5 [Гц]
Passband3_01 = f(I_S3_01); %Полоса пропускания АЧС по уровню 0.1 [Гц]
fprintf('Полоса пропускания АЧС для сигнала (с увеличенной амплитудой) по уровню 0.5: %f [Гц]\n', Passband3_05); %Вывод информации в командное окно
fprintf('Полоса пропускания АЧС для сигнала (с увеличенной амплитудой) по уровню 0.1: %f [Гц]\n', Passband3_01); %Вывод информации в командное окно
fprintf('\n'); %Пропуск строки
S4_05 = 0.5*max(S4_in); %Амплитуда по уровню 0.5 максимальной [В*с]
S4_01 = 0.1*max(S4_in); %Амплитуда по уровню 0.1 максимальной [В*с]
I_S4_05 = find(abs(S4_in)>=S4_05,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.5
I_S4_01 = find(abs(S4_in)>=S4_01,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.1
Passband4_05 = f(I_S4_05); %Полоса пропускания АЧС по уровню 0.5 [Гц]
Passband4_01 = f(I_S4_01); %Полоса пропускания АЧС по уровню 0.1 [Гц]
fprintf('Полоса пропускания АЧС для сигнала (с увеличенной длительностью) по уровню 0.5: %f [Гц]\n', Passband4_05); %Вывод информации в командное окно
fprintf('Полоса пропускания АЧС для сигнала (с увеличенной длительностью) по уровню 0.1: %f [Гц]\n', Passband4_01); %Вывод информации в командное окно
fprintf('\n'); %Пропуск строки
S5_05 = 0.5*max(S5_in); %Амплитуда по уровню 0.5 максимальной [В*с]
S5_01 = 0.1*max(S5_in); %Амплитуда по уровню 0.1 максимальной [В*с]
I_S5_05 = find(abs(S5_in)>=S5_05,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.5
I_S5_01 = find(abs(S5_in)>=S5_01,1,'last'); %Индекс частоты c амплитудой сигнала по уровню 0.1
Passband5_05 = f(I_S5_05); %Полоса пропускания АЧС по уровню 0.5 [Гц]
Passband5_01 = f(I_S5_01); %Полоса пропускания АЧС по уровню 0.1 [Гц]
fprintf('Полоса пропускания АЧС для сигнала (с уменьшенной длительностью) по уровню 0.5: %f [Гц]\n', Passband5_05); %Вывод информации в командное окно
fprintf('Полоса пропускания АЧС для сигнала (с уменьшенной длительностью) по уровню 0.1: %f [Гц]\n', Passband5_01); %Вывод информации в командное окно
fprintf('\n'); %Пропуск строки

% Часть №4
Evh = (sum(U1_in.^2))/Fd; %Энергия сигнала[В^2/Гц]
N01=Evh/(10^(q/10)); %Энергия шума при соотношении сигнал/шум=q [В^2/Гц]
N1_in = sqrt(N01).*randn(1,length(U1_in)); %Шум на входе фильтра 
U1N_in = N1_in + U1_in; %Добавление шума
SN1_in = fftshift(fft(N1_in)); %Спектр шума
Sigma = std(N1_in); %СКО шума
norm6 = max(U1_in)+sqrt(3)*Sigma; %Максимум сигнала с добавленным шумом [В]
figure; %Создание нового окна для графиков
plot (time, U1N_in./norm6,'LineWidth',2.5); %Построение эпюры сигнала с шумом на входе фильтра(Рис. 4.1)
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
title(sprintf('Сигнал с шумом на входе фильтра, нормированный к %f[B] при отношении сигнал/шум= %d[дБ]',norm6,q));%Присвоение названия графику
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/(Umax+3^{1/2}\cdot\sigma)'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

% Часть №4.1
figure; %Создание нового окна для графиков
S1N_in = ifftshift(fft(U1N_in)); %Получение двустороннего спектра заданного сигнала с шумом;
subplot (2,1,1); %Выбор верхней половины окна для отображения графика
norm7 = max(abs(S1N_in)./Fd); %Максимум АЧС [В*с]
plot (f,abs(S1N_in./Fd)./norm7,'LineWidth',2.5); %Построение АЧС сигнала с шумом на входе фильтра(Рис. 4.2)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('АЧС сигнала с шумом на входе фильтра, нормированный к %f[В*с] при отношении сигнал/шум= %d[дБ]',norm7,q)); %Присвоение названия графику
xlabel('f');%Название оси графика
ylabel('S(f)/Smax'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

subplot (2,1,2); %Выбор нижней половины окна для отображения графика
plot (f,unwrap(angle(S1N_in./Fd)),'LineWidth',2.5); %Построение ФЧС сигнала с шумом на входе фильтра(Рис. 4.2)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('ФЧС сигнала с шумом на входе фильтра при отношении сигнал/шум= %d[дБ]',q)); %Присвоение названия графику
xlabel('f');%Название оси абсцисс графика
ylabel('\Psi(f) [рад]'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

% Часть № 4.2
figure; %Создание нового окна для графиков
S1N_out = S1N_in.*Kmf1; %Прохождение сигнала с шумом через фильтр [В*с] 
subplot (2,1,1); %Выбор верхней половины окна для отображения графика
norm9 = max(abs(S1N_out)./(Fd^2)); %Максимум АЧС [В*с]
plot (f,(abs(S1N_out)./(Fd^2))./norm9,'LineWidth',2.5); %Построение АЧС сигнала с шумом на выходе фильтра(Рис. 4.3)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('АЧС сигнала с шумом на выходе фильтра, нормированный к %f[В*с] при отношении сигнал/шум= %d[дБ]',norm9,q)); %Присвоение названия графику
xlabel('f');%Название оси абсцисс графика
ylabel('S(f)/Smax'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

subplot (2,1,2); %Выбор нижней половины окна для отображения графика
plot (f,unwrap(angle(S1N_out./Fd^2)),'LineWidth',2.5); %Построение ФЧС сигнала с шумом на выходе фильтра(Рис. 4.3)
xlim([-10*Passband1_05 10*Passband1_05]); %Границы графика
title(sprintf('ФЧС сигнала с шумом на выходе фильтра при отношении сигнал/шум= %d[дБ]',q));%Присвоение названия графику
xlabel('f');%Название оси абсцисс графика
ylabel('\Psi(f) [рад]'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks.*(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'/Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'/Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового графика
U1N_out = fftshift(ifft(fftshift(S1N_out./(Fd)))); %Получение сигнала на выходе фильтра
norm11 = max(U1N_out); %Максимальное значение напряжения сигнала [В]
plot (time,U1N_out./norm11,'LineWidth',2.5); %Построение эпюры сигнала на выходе фильтра(Рис. 4.4)
axis([-2*Tu 2*Tu -0.5 1.5]); %Границы графика
title(sprintf('Сигнал на выходе фильтра, нормированный к %f[B] при отношении сигнал/шум= %d[дБ]',norm11,q)); %Название графика
xlabel('t-t_0-t_ф'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

% Часть № 4.3
S1_out = S1_in.*Kmf1; %Прохождение сигнала без шума через согласованый фильтр [В*с]
U1_out = ifft(S1_out); %Сигнала без шума на выходе фильтра [В]
SN0ise1_out = N1_in.*Kmf1; %Прохождение сигнала без шума через согласованый фильтр [В*с]
E_in1 = (sum(abs(U1_in.^2)))/Fd; %Энергия сигнала на входе [В^2/Гц]
N0_in1 = (sum(abs(N1_in.^2)))/length(N1_in); %Энергия шума на входе [В^2/Гц]
E_out1 = (sum((abs(U1_out./Fd)).^2))/Fd; %Энергия сигнала на выходе [В^2/Гц]
N0_out1 = (sum((abs(SN0ise1_out./Fd)).^2))/Fd; %Энергия шума на выходе [В^2/Гц]  
Qin1=E_in1/N0_in1; %Отношения сигнал/шум на входе [раз]
Qout1=E_out1/N0_out1; %Отношения сигнал/шум на выходе [раз]

% Часть № 4.4 
figure; %Создание нового окна для графиков
Evh2 = (sum(U2_in.^2))/Fd; %Энергия сигнала с уменьшенной амплитудой
N02=Evh2/(10^(q/10)); %Энергия шума при соотношении сигнал/шум=q
N2_in = sqrt(N02).*randn(1,length(U2_in)); %Шум на входе фильтра 
U2N_in = N2_in + U2_in; %Добавление шума
SN2_in = fftshift(fft(U2N_in)); %Спектр сигнала и шума
Sigma = std(N2_in); %СКО шума
norm26 = max(U2_in)+sqrt(3)*Sigma; %Максимум сигнала с добавленным шумом [В]
plot (time, U1N_in./norm6,'b', time, U2N_in./norm6,'--r','LineWidth',2.5); %Построение эпюры сигнала с шумом на входе фильтра(5.1)
legend('Заданный сигнал','Сигнал с уменьшенной на 20% амплитудой'); %Описание линий на графике
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
title(sprintf('Сравнение сигналов с шумом на входе фильтра, нормированных к %f[B] при отношении сигнал/шум= %d[дБ]',norm6,q));%Присвоение названия графику
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/(Umax+3^{1/2}\cdot\sigma)'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
Evh3 = (sum(U3_in.^2))/Fd; %Энергия сигнала с увеличенной амплитудой
N03=Evh3/(10^(q/10)); %Энергия шума при соотношении сигнал/шум=q
N3_in = sqrt(N03).*randn(1,length(U3_in)); %Шум на входе фильтра 
U3N_in = N3_in + U3_in; %Добавление шума
SN3_in = fftshift(fft(U3N_in)); %Спектр сигнала и шума
Sigma = std(N3_in); %СКО шума
norm36 = max(U3_in)+sqrt(3)*Sigma; %Максимум сигнала с добавленным шумом [В]
plot (time, U1N_in./norm36,'b', time, U3N_in./norm36,'--r','LineWidth',2.5); %Построение эпюры сигнала с шумом на входе фильтра(5.3)
legend('Заданный сигнал','Сигнал с увеличенной на 20% амплитудой'); %Описание линий на графике
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
title(sprintf('Сравнение сигналов с шумом на входе фильтра, нормированных к %f[B] при отношении сигнал/шум= %d[дБ]',norm36,q));%Присвоение названия графику
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/(Umax+3^{1/2}\cdot\sigma)'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
Evh4 = (sum(U4_in.^2))/Fd; %Энергия сигнала с увеличенной длительностью
N04=Evh4/(10^(q/10)); %Энергия шума при соотношении сигнал/шум=q
N4_in = sqrt(N04).*randn(1,length(U4_in)); %Шум на входе фильтра 
U4N_in = N4_in + U4_in; %Добавление шума
SN4_in = fftshift(fft(U4N_in)); %Спектр сигнала и шума
Sigma = std(N4_in); %СКО шума
norm46 = max(U4_in)+sqrt(3)*Sigma; %Максимум сигнала с добавленным шумом [В]
plot (time, U1N_in./norm6,'b', time, U4N_in./norm6,'--r','LineWidth',2.5); %Построение эпюры сигнала с шумом на входе фильтра(5.5)
legend('Заданный сигнал','Сигнал с увеличенной на 20% длительностью'); %Описание линий на графике
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
title(sprintf('Сравнение сигналов с шумом на входе фильтра, нормированных к %f[B] при отношении сигнал/шум= %d[дБ]',norm6,q));%Присвоение названия графику
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/(Umax+3^{1/2}\cdot\sigma)'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

figure; %Создание нового окна для графиков
Evh5 = (sum(U5_in.^2))/Fd; %Энергия сигнала с уменьшенной длительностью
N05=Evh5/(10^(q/10)); %Энергия шума при соотношении сигнал/шум=q
N5_in = sqrt(N05).*randn(1,length(U5_in)); %Шум на входе фильтра 
U5N_in = N5_in + U5_in; %Добавление шума
SN5_in = fftshift(fft(U5N_in)); %Спектр сигнала и шума
Sigma = std(N5_in); %СКО шума
norm56 = max(U5_in)+sqrt(3)*Sigma; %Максимум сигнала с добавленным шумом [В]
plot (time, U1N_in./norm6,'b', time, U5N_in./norm6,'--r','LineWidth',2.5); %Построение эпюры сигнала с шумом на входе фильтра(5.7)
legend('Заданный сигнал','Сигнал с уменьшенной на 20% длительностью'); %Описание линий на графике
axis([-2*Tu+t0 2*Tu+t0 -0.5 1.5]); %Границы графика
title(sprintf('Сравнение сигналов с шумом на входе фильтра, нормированных к %f[B] при отношении сигнал/шум= %d[дБ]',norm6,q));%Присвоение названия графику
xlabel('t-t_0'); %Название оси абсцисс графика
ylabel('U(t)/(Umax+3^{1/2}\cdot\sigma)'); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

Kmf2 = conj(S2_in); %КЧХ согласованного фильтра для сигнала с уменьшенной на 20% амплитудой
Kmf3 = conj(S3_in); %КЧХ согласованного фильтра для сигнала с увеличенной на 20% амплитудой
Kmf4 = conj(S4_in); %КЧХ согласованного фильтра для сигнала с увеличенной на 20% длительностью
Kmf5 = conj(S5_in); %КЧХ согласованного фильтра для сигнала с уменьшенной на 20% длительностью

S2N_out = SN2_in.*Kmf2; %Прохождение сигнала с шумом через фильтр [В*с] 
figure; %Создание нового графика
U2N_out = fftshift(ifft(fftshift(S2N_out./(Fd^1)))); %Получение сигнала на выходе фильтра
plot (time,U1N_out./norm11,'b',time,U2N_out./norm11,'--r','LineWidth',2.5); %Построение эпюры сигнала на выходе фильтра(5.2)
legend('Заданный сигнал','Сигнал с уменьшенной на 20% амплитудой'); %Описание линий на графике
axis([-2*Tu 2*Tu -0.5 1.5]); %Границы графика
title(sprintf('Сравнение сигналов на выходе фильтра, нормированных к %f[B] при отношении сигнал/шум= %d[дБ]',norm11,q)); %Название графика
xlabel('t-t_0-t_ф'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

S3N_out = SN3_in.*Kmf3; %Прохождение сигнала с шумом через фильтр [В*с] 
figure; %Создание нового графика
U3N_out = fftshift(ifft(fftshift(S3N_out./(Fd^1)))); %Получение сигнала на выходе фильтра
norm311 = max(U3N_out); %Максимальное значение напряжения сигнала [В]
plot (time,U1N_out./norm311,'b',time,U3N_out./norm311,'--r','LineWidth',2.5); %Построение эпюры сигнала на выходе фильтра(5.4)
legend('Заданный сигнал','Сигнал с увеличенной на 20% амплитудой'); %Описание линий на графике
axis([-2*Tu 2*Tu -0.5 1.5]); %Границы графика
title(sprintf('Сравнение сигналов на выходе фильтра, нормированных к %f[B] при отношении сигнал/шум= %d[дБ]',norm311,q)); %Название графика
xlabel('t-t_0-t_ф'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

S4N_out = SN4_in.*Kmf4; %Прохождение сигнала с шумом через фильтр [В*с] 
figure; %Создание нового графика
U4N_out = fftshift(ifft(fftshift(S4N_out./(Fd^1)))); %Получение сигнала на выходе фильтра
norm411 = max(U4N_out); %Максимальное значение напряжения сигнала [В]
plot (time,U1N_out./norm411,'b',time,U4N_out./norm411,'--r','LineWidth',2.5); %Построение эпюры сигнала на выходе фильтра(5.6)
legend('Заданный сигнал','Сигнал с увеличенной на 20% длительностью'); %Описание линий на графике
axis([-2*Tu 2*Tu -0.5 1.5]); %Границы графика
title(sprintf('Сравнение сигналов на выходе фильтра, нормированных к %f[B] при отношении сигнал/шум= %d[дБ]',norm411,q)); %Название графика
xlabel('t-t_0-t_ф'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

S5N_out = SN5_in.*Kmf5; %Прохождение сигнала с шумом через фильтр [В*с] 
figure; %Создание нового графика
U5N_out = fftshift(ifft(fftshift(S5N_out./(Fd^1)))); %Получение сигнала на выходе фильтра
plot (time,U1N_out./norm11,'b',time,U5N_out./norm11,'--r','LineWidth',2.5); %Построение эпюры сигнала на выходе фильтра(5.8)
legend('Заданный сигнал','Сигнал с уменьшенной на 20% длительностью'); %Описание линий на графике
axis([-2*Tu 2*Tu -0.5 1.5]); %Границы графика
title(sprintf('Сравнение сигналов на выходе фильтра, нормированных к %f[B] при отношении сигнал/шум= %d[дБ]',norm11,q)); %Название графика
xlabel('t-t_0-t_ф'); %Название оси абсцисс графика
ylabel('U(t)/Umax '); %Название оси ординат графика
grid on; %Добавление сетки к графику

xticks = get(gca,'XTick'); %Получение делений сетки
xticks = xticks./(Tu); %Нормировка к длительности сигнала
buf = [num2str(xticks(1)),'*Tзc    ']; %Создание нового деления
xticks2 = buf; %Добавление нового деления к новой сетке делений
num = length(buf); %Длина слова первого деления 
for i=2:(length(xticks)) %Цикл формирования делений
    buf = [num2str(xticks(i)),'*Tзc']; %Создание нового деления
    while(length(buf)<num) %Обнаружение и удлиннение коротких слов
            buf = [buf,' ']; %Добавление пробелов в конец слов
    end
    xticks2 = [xticks2; buf]; %Добавление нового деления к новой сетке делений
end;
set(gca,'XTickLabel',xticks2); %Присвоение новых делений сетки

% Часть № 4.5
K1 = Qout1/Qin1; %Выигрыш в отношении сигнал/шум [раз]
fprintf('Отношение сигнал/шум на входе фильтра при заданном сигнале: %f[раз] или %f[дБ]\n', Qin1, 10*log10(Qin1)); %Вывод информации в командное окно 
fprintf('Отношение сигнал/шум на выходе фильтра при заданном сигнале: %f[раз] или %f[дБ]\n', Qout1, 10*log10(Qout1)); %Вывод информации в командное окно 
fprintf('Выигрыш в отношении сигнал/шум, реализуемый при фильтрации заданного сигнала: %f[раз] или %f[дБ] \n',K1, 10*log10(K1)); %Вывод информации в командное окно

%Часть № 5
fprintf('\n'); %Пропуск строки
S2_out = S2_in.*Kmf2; %Прохождение сигнала без шума через согласованый фильтр [В*с]
U2_out = ifft(S2_out); %Сигнала без шума на выходе фильтра [В]
SN0ise2_out = N2_in.*Kmf2; %Прохождение сигнала без шума через согласованый фильтр [В*с]
E_in2 = (sum(abs(U2_in.^2)))/Fd; %Энергия сигнала на входе [В^2/Гц]
N0_in2 = (sum(abs(N2_in.^2)))/length(N2_in); %Энергия шума на входе [В^2/Гц]
E_out2 = (sum((abs(U2_out./Fd)).^2))/Fd; %Энергия сигнала на выходе [В^2/Гц]
N0_out2 = (sum((abs(SN0ise2_out./Fd)).^2))/Fd; %Энергия шума на выходе [В^2/Гц]
Qin2=E_in2/N0_in2; %Отношения сигнал/шум на входе [раз]
Qout2=E_out2/N0_out2; %Отношения сигнал/шум на выходе [раз]
K2 = Qout2/Qin2; %Выигрыш в отношении сигнал/шум [раз]
fprintf('Отношение сигнал/шум на входе фильтра при сигнале с уменьшенной амплитудой: %f[раз] или %f[дБ]\n', Qin2, 10*log10(Qin2)); %Вывод информации в командное окно 
fprintf('Отношение сигнал/шум на выходе фильтра при заданном сигнале с уменьшенной амплитудой: %f[раз] или %f[дБ]\n', Qout2, 10*log10(Qout2)); %Вывод информации в командное окно 
fprintf('Выигрыш в отношении сигнал/шум, реализуемый при фильтрации сигнала с уменьшенной амплитудой: %f[раз] или %f[дБ] \n',K2, 10*log10(K2)); %Вывод информации в командное окно

fprintf('\n'); %Пропуск строки
S3_out = S3_in.*Kmf3; %Прохождение сигнала без шума через согласованый фильтр [В*с]
U3_out = ifft(S3_out); %Сигнала без шума на выходе фильтра [В]
SN0ise3_out = N3_in.*Kmf3; %Прохождение сигнала без шума через согласованый фильтр [В*с]
E_in3 = (sum(abs(U3_in.^2)))/Fd; %Энергия сигнала на входе [В^2/Гц]
N0_in3 = (sum(abs(N3_in.^2)))/length(N3_in); %Энергия шума на входе [В^2/Гц]
E_out3 = (sum((abs(U3_out./Fd)).^2))/Fd; %Энергия сигнала на выходе [В^2/Гц]
N0_out3 = (sum((abs(SN0ise3_out./Fd)).^2))/Fd; %Энергия шума на выходе [В^2/Гц]
Qin3=E_in3/N0_in3; %Отношения сигнал/шум на входе [раз]
Qout3=E_out3/N0_out3; %Отношения сигнал/шум на выходе [раз]
K3 = Qout3/Qin3; %Выигрыш в отношении сигнал/шум [раз]
fprintf('Отношение сигнал/шум на входе фильтра при сигнале с увеличенной амплитудой: %f[раз] или %f[дБ]\n', Qin3, 10*log10(Qin3)); %Вывод информации в командное окно 
fprintf('Отношение сигнал/шум на выходе фильтра при заданном сигнале с увеличенной амплитудой: %f[раз] или %f[дБ]\n', Qout3, 10*log10(Qout3)); %Вывод информации в командное окно 
fprintf('Выигрыш в отношении сигнал/шум, реализуемый при фильтрации сигнала с увеличенной амплитудой: %f[раз] или %f[дБ] \n',K3, 10*log10(K3)); %Вывод информации в командное окно

fprintf('\n'); %Пропуск строки
S4_out = S4_in.*Kmf4; %Прохождение сигнала без шума через согласованый фильтр [В*с]
U4_out = ifft(S4_out); %Сигнала без шума на выходе фильтра [В]
SN0ise4_out = N4_in.*Kmf4; %Прохождение сигнала без шума через согласованый фильтр [В*с]
E_in4 = (sum(abs(U4_in.^2)))/Fd; %Энергия сигнала на входе [В^2/Гц]
N0_in4 = (sum(abs(N4_in.^2)))/length(N4_in); %Энергия шума на входе [В^2/Гц]
E_out4 = (sum((abs(U4_out./Fd)).^2))/Fd; %Энергия сигнала на выходе [В^2/Гц]
N0_out4 = (sum((abs(SN0ise4_out./Fd)).^2))/Fd; %Энергия шума на выходе [В^2/Гц]
Qin4=E_in4/N0_in4; %Отношения сигнал/шум на входе [раз]
Qout4=E_out4/N0_out4; %Отношения сигнал/шум на выходе [раз]
K4 = Qout4/Qin4; %Выигрыш в отношении сигнал/шум [раз]
fprintf('Отношение сигнал/шум на входе фильтра при сигнале с увеличенной длительностью: %f[раз] или %f[дБ]\n', Qin4, 10*log10(Qin4)); %Вывод информации в командное окно 
fprintf('Отношение сигнал/шум на выходе фильтра при заданном сигнале с увеличенной длительностью: %f[раз] или %f[дБ]\n', Qout4, 10*log10(Qout4)); %Вывод информации в командное окно 
fprintf('Выигрыш в отношении сигнал/шум, реализуемый при фильтрации сигнала с увеличенной длительностью: %f[раз] или %f[дБ] \n',K4, 10*log10(K4)); %Вывод информации в командное окно

fprintf('\n'); %Пропуск строки
S5_out = S5_in.*Kmf5; %Прохождение сигнала без шума через согласованый фильтр [В*с]
U5_out = ifft(S5_out); %Сигнала без шума на выходе фильтра [В]
SN0ise5_out = N5_in.*Kmf5; %Прохождение сигнала без шума через согласованый фильтр [В*с]
E_in5 = (sum(abs(U5_in.^2)))/Fd; %Энергия сигнала на входе [В^2/Гц]
N0_in5 = (sum(abs(N5_in.^2)))/length(N5_in); %Энергия шума на входе [В^2/Гц]
E_out5 = (sum((abs(U5_out./Fd)).^2))/Fd; %Энергия сигнала на выходе [В^2/Гц]
N0_out5 = (sum((abs(SN0ise5_out./Fd)).^2))/Fd; %Энергия шума на выходе [В^2/Гц]
Qin5=E_in5/N0_in5; %Отношения сигнал/шум на входе [раз]
Qout5=E_out5/N0_out5; %Отношения сигнал/шум на выходе [раз]
K5 = Qout5/Qin5; %Выигрыш в отношении сигнал/шум [раз]
fprintf('Отношение сигнал/шум на входе фильтра при сигнале с уменьшенной длительностью: %f[раз] или %f[дБ]\n', Qin5, 10*log10(Qin5)); %Вывод информации в командное окно 
fprintf('Отношение сигнал/шум на выходе фильтра при заданном сигнале с уменьшенной длительностью: %f[раз] или %f[дБ]\n', Qout5, 10*log10(Qout5)); %Вывод информации в командное окно 
fprintf('Выигрыш в отношении сигнал/шум, реализуемый при фильтрации сигнала с уменьшенной длительностью: %f[раз] или %f[дБ] \n',K5, 10*log10(K5)); %Вывод информации в командное окно
